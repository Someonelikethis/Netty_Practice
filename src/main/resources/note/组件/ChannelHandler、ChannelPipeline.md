###ChannelHandler和ChannelPipeline

管理数据流以及执行应用程序处理逻辑的组件

ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器

ChannelPipeline提供了ChannelHandler链的容器
当Channel被创建时，它会被自动地分配到它专属的ChannelPipeline

ChannelHandler安装到ChannelPipeline中的过程：
①一个ChannelInitializer的实现被注册到ServerBootstrap/Bootstrap中;
②当ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler;
③ChannelInitializer将它自己从ChannelPipeline中移除。


ChannelHandler的执行顺序是由它们被添加的顺序所决定的。实际上，ChannelPipeline就是这些ChannelHandler的编排顺序。

ChannelHandler根据入站和出站被分为ChannelInboundHandler和ChannelOutboundHandler。

当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定。
虽然ChannelHandlerContext可以被用于获取底层的Channel，但是它主要还是被用于写出站数据。

通过使用作为参数传递到每个方法的ChannelHandlerContext,事件可以被传递给当前ChannelHandler链中的下一个ChannelHandler。

Netty确保数据只会在具有相同定向类型(入站、出站)的两个ChannelHandler之间传递。

Netty以适配器类的形式提供了大量默认的ChannelHandler实现
常用适配器类：
ChannelHandlerAdapter
ChannelInboundHandlerAdapter
ChannelOutboundHandlerAdapter
ChannelDuplexHandle

####两种发送消息的方式
一、直接写到Channel中，会导致消息从ChannelPipeline的尾端开始流动
二、写到和ChannelHandler相关联的ChannelHandlerContext中，会导致消息从ChannelPipeline的下一个ChannelHandler开始流动。

####3个ChannelHandler的子类型——编码器、解码器和SimpleChannelInboundHandler<T>

入站消息会被解码——从字节转换为另一种格式，通常是一个Java对象
在channelRead()方法中调用decode()方法进行解码

出站消息会被编码——从当前格式被编码为字节
在write()方法中调用encode()方法进行编码

编码、解码的原因：网络数据总是一系列的字节。

